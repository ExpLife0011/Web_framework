/* HTTPS子类 */
#ifndef SERVER_HTTPS_H_INCLUDED
#define SERVER_HTTPS_H_INCLUDED

#include "server_http.h"
#include<boost/asio/ssl.h>

namespace Wenmingxing {
    //定义HTTPS类型
    typedef boost::asio::ssl::stream<boost::asio::ip::tcp::socket> HTTPS;

    //定义HTTPS服务，模板类型为HTTPS
    template<>
    class Server<HTTPS> : public ServerBase<HTTPS> {
    public:
        //一个HTTPS服务器比http服务器多增加两个参数，一个是证书文件，另一个是私钥文件
        Server(unsigned short port, size_t num_threads,
               const std::string& cert_file, const std::string& private_key_file) :
               ServerBase<HTTPS>::ServerBase(port, num_threads), context(boost::asio::ssl::context::sslv23) {
                   //使用证书文件
                   context.use_certificate_chain_file(cert_file);
                   //使用私钥文件，相比之下需要多传入一个参数来指明文件的格式
                   context.use_private_key_file(private_key_file, boost::asio::ssl::context::pem);
                   }
    private:
        //和http服务器相比，需要多定义一个ssl context对象
        boost::asio::ssl::context context;

        /* HTTPS服务器和http服务器相比
         * 其区别在于对socket对象的构造方式有所不同
         * HTTPS会在socket这一步对IO流进行加密
         * 因此实现accept方法需要对socket用ssl context初始化
        */
        void accept() {
            //为当前连接创建一个新的socket
            //shared_ptr用于传递临时对象给匿名函数
            //socket类型会被推导为shared_ptr<HTTPS>
            auto socket = std::make_shared<HTTPS>(m_io_service, context);

            accetpor.async_accept (
                                   (*socket).lowest_layer(),
                                   [this, socket](const boost::system::error_code& ec) {
                                    //立即启动并接受一个新连接
                                    accept();
                                    //处理错误
                                    if(!ec) {
                                        (*socket).async_handshake(boost::asio::ssl::stream_base::server,
                                                                  [this, socket](const boost::system::error_code& ec) {
                                                                  if (!ec) process_request_and_respond(socket);
                                                                  });
                                    }
                                   });
        }

    };
}

#endif // SERVER_HTTPS_H_INCLUDED
